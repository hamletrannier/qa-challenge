"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = require("../consts");
const fetch_response_1 = __importDefault(require("./fetch-response"));
const texts_1 = require("../texts");
function removeNullValues(key, value) {
    if (value !== null)
        return value;
    return void 0;
}
class Transport {
    constructor(fetch, dashboardUrl, authenticationToken, isLogEnabled, logger, responseTimeout, requestRetryCount) {
        this._authenticationToken = authenticationToken;
        this._dashboardUrl = dashboardUrl;
        this._isLogEnabled = isLogEnabled;
        this._logger = logger;
        this._responseTimeout = responseTimeout;
        this._requestRetryCount = requestRetryCount;
        this._fetch = fetch;
    }
    async _sendCommand(command) {
        return this.fetch(`${this._dashboardUrl}/api/commands/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Cookie': `tc-dashboard-jwt=${this._authenticationToken}`
            },
            body: JSON.stringify(command, removeNullValues)
        }, this._responseTimeout);
    }
    async _fetchWithRequestTimeout(url, requestOptions, requestTimeout) {
        let timeout = null;
        const result = await new Promise((resolve, reject) => {
            timeout = setTimeout(() => {
                const error = new Error(consts_1.CLIENTTIMEOUT_ERROR_MSG);
                error.code = consts_1.CLIENTTIMEOUT_ERROR_MSG;
                reject(error);
            }, requestTimeout);
            this._fetch(url, requestOptions).then(resolve, reject);
        });
        if (timeout)
            clearTimeout(timeout);
        return result;
    }
    async fetch(url, requestOptions, requestTimeout) {
        let retryCount = 0;
        let response;
        do {
            try {
                if (requestTimeout !== void 0)
                    response = new fetch_response_1.default(await this._fetchWithRequestTimeout(url, requestOptions, requestTimeout));
                else
                    response = new fetch_response_1.default(await this._fetch(url, requestOptions));
            }
            catch (e) {
                if (this._isLogEnabled)
                    this._logger.log(`${texts_1.FETCH_NETWORK_CONNECTION_ERROR} ${url}. Retry count: ${retryCount}`);
                if (consts_1.RETRY_ERROR_CODES.includes(e.code) && retryCount++ < this._requestRetryCount)
                    continue;
                return new fetch_response_1.default(null, texts_1.FETCH_NETWORK_CONNECTION_ERROR, e);
            }
            if ([consts_1.SERVICE_UNAVAILABLE_ERROR_CODE, consts_1.CONCURRENT_ERROR_CODE].includes(response.status) && retryCount++ < this._requestRetryCount) {
                if (this._isLogEnabled)
                    this._logger.log(`${url} ${response}`);
                continue;
            }
            return response;
        } while (true);
    }
    async fetchFromDashboard(relativeUrl) {
        return await this.fetch(`${this._dashboardUrl}/${relativeUrl}`, {
            method: 'GET',
            headers: {
                authorization: `Bearer ${this._authenticationToken}`
            }
        }, this._responseTimeout);
    }
    async sendResolveCommand(command) {
        const { aggregateId, type: commandType } = command;
        if (!this._authenticationToken)
            return;
        const response = await this._sendCommand(command);
        if (!response.ok)
            this._logger.error(`${aggregateId} ${commandType} ${response}`);
        else if (this._isLogEnabled)
            this._logger.log(`${aggregateId} ${commandType} ${response}`);
    }
}
exports.default = Transport;
