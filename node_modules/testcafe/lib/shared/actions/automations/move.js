"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_1 = require("../../adapter");
const next_tick_1 = __importDefault(require("../../utils/next-tick"));
const settings_1 = __importDefault(require("./settings"));
const options_1 = require("../../../test-run/commands/options");
const last_hovered_element_holder_1 = __importDefault(require("./last-hovered-element-holder"));
const MOVE_REQUEST_CMD = 'automation|move|request';
const MOVE_RESPONSE_CMD = 'automation|move|response';
const get_automation_point_1 = __importDefault(require("../utils/get-automation-point"));
const axis_values_1 = __importDefault(require("../../utils/values/axis-values"));
const promise_1 = require("../../utils/promise");
const get_device_point_1 = __importDefault(require("../utils/get-device-point"));
class MoveAutomation {
    constructor(el, offset, win, cursor, moveOptions) {
        this.touchMode = adapter_1.adapter.featureDetection.isTouchDevice;
        this.moveEvent = this.touchMode ? 'touchmove' : 'mousemove';
        this.automationSettings = new settings_1.default(moveOptions.speed);
        this.cursorSpeed = this._getCursorSpeed();
        this.element = el;
        this.window = win;
        this.offset = offset;
        this.cursor = cursor;
        this.minMovingTime = moveOptions.minMovingTime || 0;
        this.modifiers = moveOptions.modifiers || {};
        this.skipScrolling = moveOptions.skipScrolling;
        this.skipDefaultDragBehavior = moveOptions.skipDefaultDragBehavior;
        this.speed = moveOptions.speed;
        this.firstMovingStepOccured = false;
    }
    static async create(el, win, cursor, moveOptions) {
        const { element, offset } = await MoveAutomation.getTarget(el, win, new axis_values_1.default(moveOptions.offsetX, moveOptions.offsetY));
        return new MoveAutomation(element, offset, win, cursor, moveOptions);
    }
    static getTarget(element, window, offset) {
        // NOTE: if the target point (considering offsets) is out of
        // the element change the target element to the document element
        return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.containsOffset(element, offset.x, offset.y))
            .then(containsOffset => {
            if (!containsOffset) {
                return Promise.all([
                    get_automation_point_1.default(element, offset),
                    adapter_1.adapter.dom.getDocumentElement(window),
                ])
                    .then(([point, docEl]) => ({ element: docEl, offset: point }));
            }
            return { element, offset };
        });
    }
    _getCursorSpeed() {
        return this.automationSettings.cursorSpeed;
    }
    _getTargetClientPoint() {
        return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.style.getElementScroll(this.element))
            .then(scroll => {
            if (adapter_1.adapter.dom.isHtmlElement(this.element))
                return axis_values_1.default.create(this.offset).sub(axis_values_1.default.create(scroll));
            return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.getClientPosition(this.element))
                .then(clientPosition => {
                const isDocumentBody = adapter_1.adapter.dom.isBodyElement(this.element);
                const clientPoint = axis_values_1.default.create(clientPosition).add(this.offset);
                if (!isDocumentBody)
                    clientPoint.sub(axis_values_1.default.create(scroll));
                return clientPoint.round(Math.floor);
            });
        });
    }
    _getEventSequenceOptions(currPosition) {
        const button = adapter_1.adapter.event.BUTTONS_PARAMETER.noButton;
        return get_device_point_1.default(currPosition)
            .then(devicePoint => {
            const eventOptions = {
                clientX: currPosition.x,
                clientY: currPosition.y,
                screenX: devicePoint === null || devicePoint === void 0 ? void 0 : devicePoint.x,
                screenY: devicePoint === null || devicePoint === void 0 ? void 0 : devicePoint.y,
                buttons: button,
                ctrl: this.modifiers.ctrl,
                alt: this.modifiers.alt,
                shift: this.modifiers.shift,
                meta: this.modifiers.meta,
            };
            return { eventOptions, eventSequenceOptions: { moveEvent: this.moveEvent } };
        });
    }
    async _runEventSequence(currentElement, { eventOptions, eventSequenceOptions }) {
        const eventSequence = await adapter_1.adapter.createEventSequence(false, this.firstMovingStepOccured, eventSequenceOptions);
        return eventSequence.run(currentElement, last_hovered_element_holder_1.default.get(), eventOptions, null, null);
    }
    _emulateEvents(currentElement, currPosition) {
        return this._getEventSequenceOptions(currPosition)
            .then(options => {
            return this._runEventSequence(currentElement, options);
        })
            .then(() => {
            this.firstMovingStepOccured = true;
            last_hovered_element_holder_1.default.set(currentElement);
        });
    }
    _movingStep(currPosition) {
        return this.cursor.move(currPosition)
            .then(() => adapter_1.adapter.getElementExceptUI(this.cursor.getPosition()))
            // NOTE: in touch mode, events are simulated for the element for which mousedown was simulated (GH-372)
            .then(topElement => {
            const currentElement = this._getCorrectedTopElement(topElement);
            // NOTE: it can be null in IE
            if (!currentElement)
                return null;
            return this._emulateEvents(currentElement, currPosition);
        })
            .then(next_tick_1.default);
    }
    _getCorrectedTopElement(topElement) {
        return topElement;
    }
    _move(endPoint) {
        const startPoint = this.cursor.getPosition();
        const distance = axis_values_1.default.create(endPoint).sub(startPoint);
        const startTime = adapter_1.adapter.nativeMethods.dateNow();
        const movingTime = Math.max(Math.max(Math.abs(distance.x), Math.abs(distance.y)) / this.cursorSpeed, this.minMovingTime);
        let currPosition = axis_values_1.default.create(startPoint);
        let isFirstStep = true;
        return promise_1.whilst(() => !currPosition.eql(endPoint), () => {
            if (this._needMoveCursorImmediately())
                currPosition = axis_values_1.default.create(endPoint);
            else if (isFirstStep) {
                isFirstStep = false;
                // NOTE: the mousemove event can't be simulated at the point where the cursor
                // was located at the start. Therefore, we add a minimal distance 1 px.
                currPosition.add({
                    x: distance.x > 0 ? 1 : -1,
                    y: distance.y > 0 ? 1 : -1,
                });
            }
            else {
                const progress = Math.min((adapter_1.adapter.nativeMethods.dateNow() - startTime) / movingTime, 1);
                currPosition = axis_values_1.default.create(distance).mul(progress).add(startPoint).round(Math.floor);
            }
            return this._movingStep(currPosition);
        });
    }
    //
    _needMoveCursorImmediately() {
        return this.touchMode;
    }
    _scroll() {
        if (this.skipScrolling)
            return adapter_1.adapter.PromiseCtor.resolve(false);
        const scrollOptions = new options_1.ScrollOptions({ offsetX: this.offset.x, offsetY: this.offset.y }, false);
        return adapter_1.adapter.scroll(this.element, scrollOptions);
    }
    _moveToCurrentFrame(endPoint) {
        if (this.cursor.isActive(this.window))
            return adapter_1.adapter.PromiseCtor.resolve();
        const { x, y } = this.cursor.getPosition();
        const activeWindow = this.cursor.getActiveWindow(this.window);
        let iframe = null;
        let iframeUnderCursor = null;
        const msg = {
            cmd: MOVE_REQUEST_CMD,
            startX: x,
            startY: y,
            endX: endPoint.x,
            endY: endPoint.y,
            modifiers: this.modifiers,
            speed: this.speed,
        };
        return adapter_1.adapter.PromiseCtor.resolve()
            .then(() => {
            if (activeWindow.parent === this.window) {
                return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.dom.findIframeByWindow(activeWindow))
                    .then(frame => {
                    iframe = frame;
                    return adapter_1.adapter.PromiseCtor.resolve(adapter_1.adapter.position.getIframeClientCoordinates(frame))
                        .then(rect => {
                        msg.left = rect.left;
                        msg.top = rect.top;
                        msg.right = rect.right;
                        msg.bottom = rect.bottom;
                    });
                });
            }
            return void 0;
        })
            .then(() => {
            return adapter_1.adapter.getElementExceptUI(this.cursor.getPosition());
        })
            .then(topElement => {
            iframeUnderCursor = topElement === iframe;
            if (activeWindow.parent === this.window)
                msg.iframeUnderCursor = iframeUnderCursor;
            return adapter_1.adapter.sendRequestToFrame(msg, MOVE_RESPONSE_CMD, activeWindow);
        })
            .then(message => {
            this.cursor.setActiveWindow(this.window);
            if (iframeUnderCursor || adapter_1.adapter.dom.isIframeWindow(this.window))
                return this.cursor.move(message);
            return void 0;
        });
    }
    run() {
        return this._scroll()
            .then(() => Promise.all([
            this._getTargetClientPoint(),
            adapter_1.adapter.style.getWindowDimensions(this.window),
        ]))
            .then(([endPoint, boundary]) => {
            if (!boundary.contains(endPoint))
                return void 0;
            return this._moveToCurrentFrame(endPoint)
                .then(() => this._move(endPoint));
        });
    }
}
exports.default = MoveAutomation;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW92ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvYWN0aW9ucy9hdXRvbWF0aW9ucy9tb3ZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkNBQXdDO0FBRXhDLHNFQUE2QztBQUM3QywwREFBNEM7QUFDNUMsZ0VBSTRDO0FBQzVDLGdHQUFxRTtBQUVyRSxNQUFNLGdCQUFnQixHQUFJLHlCQUF5QixDQUFDO0FBQ3BELE1BQU0saUJBQWlCLEdBQUcsMEJBQTBCLENBQUM7QUFFckQseUZBQStEO0FBQy9ELGlGQUE0RTtBQUc1RSxpREFBNkM7QUFDN0MsaUZBQXVEO0FBT3ZELE1BQXFCLGNBQWM7SUFtQi9CLFlBQXVCLEVBQUssRUFBRSxNQUE4QixFQUFFLEdBQU0sRUFBRSxNQUFpQixFQUFFLFdBQXdCO1FBQzdHLElBQUksQ0FBQyxTQUFTLEdBQUcsaUJBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUM7UUFDeEQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztRQUU1RCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBSSxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBSSxNQUFNLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBSSxNQUFNLENBQUM7UUFFdEIsSUFBSSxDQUFDLGFBQWEsR0FBYSxXQUFXLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsU0FBUyxHQUFpQixXQUFX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QzVELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFckMsT0FBTyxLQUFLLENBQUMsQ0FBQztRQUNsQixDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFFTSxHQUFHO1FBQ04sT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFO2FBQ2hCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1lBQ3BCLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUM1QixpQkFBTyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ2pELENBQUMsQ0FBQzthQUNGLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxFQUFFLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO2dCQUM1QixPQUFPLEtBQUssQ0FBQyxDQUFDO1lBRWxCLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQztpQkFDcEMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7Q0FDSjtBQTlRRCxpQ0E4UUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGFwdGVyIH0gZnJvbSAnLi4vLi4vYWRhcHRlcic7XG5cbmltcG9ydCBuZXh0VGljayBmcm9tICcuLi8uLi91dGlscy9uZXh0LXRpY2snO1xuaW1wb3J0IEF1dG9tYXRpb25TZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCB7XG4gICAgTW9kaWZpZXJzLFxuICAgIE1vdmVPcHRpb25zLFxuICAgIFNjcm9sbE9wdGlvbnMsXG59IGZyb20gJy4uLy4uLy4uL3Rlc3QtcnVuL2NvbW1hbmRzL29wdGlvbnMnO1xuaW1wb3J0IGxhc3RIb3ZlcmVkRWxlbWVudEhvbGRlciBmcm9tICcuL2xhc3QtaG92ZXJlZC1lbGVtZW50LWhvbGRlcic7XG5cbmNvbnN0IE1PVkVfUkVRVUVTVF9DTUQgID0gJ2F1dG9tYXRpb258bW92ZXxyZXF1ZXN0JztcbmNvbnN0IE1PVkVfUkVTUE9OU0VfQ01EID0gJ2F1dG9tYXRpb258bW92ZXxyZXNwb25zZSc7XG5cbmltcG9ydCBnZXRBdXRvbWF0aW9uUG9pbnQgZnJvbSAnLi4vdXRpbHMvZ2V0LWF1dG9tYXRpb24tcG9pbnQnO1xuaW1wb3J0IEF4aXNWYWx1ZXMsIHsgQXhpc1ZhbHVlc0RhdGEgfSBmcm9tICcuLi8uLi91dGlscy92YWx1ZXMvYXhpcy12YWx1ZXMnO1xuaW1wb3J0IHsgU2hhcmVkV2luZG93IH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IEN1cnNvciBmcm9tICcuLi9jdXJzb3InO1xuaW1wb3J0IHsgd2hpbHN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvbWlzZSc7XG5pbXBvcnQgZ2V0RGV2aWNlUG9pbnQgZnJvbSAnLi4vdXRpbHMvZ2V0LWRldmljZS1wb2ludCc7XG5cbmludGVyZmFjZSBNb3ZlQXV0b21hdGlvblRhcmdldDxFPiB7XG4gICAgZWxlbWVudDogRTtcbiAgICBvZmZzZXQ6IEF4aXNWYWx1ZXNEYXRhPG51bWJlcj47XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdmVBdXRvbWF0aW9uPEUsIFcgZXh0ZW5kcyBTaGFyZWRXaW5kb3c+IHtcbiAgICBwcml2YXRlIHRvdWNoTW9kZTogYm9vbGVhbjtcbiAgICBwcml2YXRlIG1vdmVFdmVudDogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBhdXRvbWF0aW9uU2V0dGluZ3M6IEF1dG9tYXRpb25TZXR0aW5ncztcblxuICAgIHByaXZhdGUgZWxlbWVudDogRTtcbiAgICBwcml2YXRlIHdpbmRvdzogVztcbiAgICBwcml2YXRlIG9mZnNldDogQXhpc1ZhbHVlc0RhdGE8bnVtYmVyPjtcbiAgICBwcml2YXRlIGN1cnNvcjogQ3Vyc29yPFc+O1xuICAgIHByaXZhdGUgc3BlZWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGN1cnNvclNwZWVkOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIG1pbk1vdmluZ1RpbWU6IG51bWJlcjtcbiAgICBwcml2YXRlIG1vZGlmaWVyczogTW9kaWZpZXJzO1xuICAgIHByaXZhdGUgc2tpcFNjcm9sbGluZzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHNraXBEZWZhdWx0RHJhZ0JlaGF2aW9yOiBib29sZWFuO1xuICAgIHByaXZhdGUgZmlyc3RNb3ZpbmdTdGVwT2NjdXJlZDogYm9vbGVhbjtcblxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvciAoZWw6IEUsIG9mZnNldDogQXhpc1ZhbHVlc0RhdGE8bnVtYmVyPiwgd2luOiBXLCBjdXJzb3I6IEN1cnNvcjxXPiwgbW92ZU9wdGlvbnM6IE1vdmVPcHRpb25zKSB7XG4gICAgICAgIHRoaXMudG91Y2hNb2RlID0gYWRhcHRlci5mZWF0dXJlRGV0ZWN0aW9uLmlzVG91Y2hEZXZpY2U7XG4gICAgICAgIHRoaXMubW92ZUV2ZW50ID0gdGhpcy50b3VjaE1vZGUgPyAndG91Y2htb3ZlJyA6ICdtb3VzZW1vdmUnO1xuXG4gICAgICAgIHRoaXMuYXV0b21hdGlvblNldHRpbmdzID0gbmV3IEF1dG9tYXRpb25TZXR0aW5ncyhtb3ZlT3B0aW9ucy5zcGVlZCk7XG5cbiAgICAgICAgdGhpcy5jdXJzb3JTcGVlZCA9IHRoaXMuX2dldEN1cnNvclNwZWVkKCk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWw7XG4gICAgICAgIHRoaXMud2luZG93ICA9IHdpbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmN1cnNvciAgPSBjdXJzb3I7XG5cbiAgICAgICAgdGhpcy5taW5Nb3ZpbmdUaW1lICAgICAgICAgICA9IG1vdmVPcHRpb25zLm1pbk1vdmluZ1RpbWUgfHwgMDtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgICAgICAgICAgICAgICA9IG1vdmVPcHRpb25zLm1vZGlmaWVycyB8fCB7fTtcbiAgICAgICAgdGhpcy5za2lwU2Nyb2xsaW5nICAgICAgICAgICA9IG1vdmVPcHRpb25zLnNraXBTY3JvbGxpbmc7XG4gICAgICAgIHRoaXMuc2tpcERlZmF1bHREcmFnQmVoYXZpb3IgPSBtb3ZlT3B0aW9ucy5za2lwRGVmYXVsdERyYWdCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5zcGVlZCAgICAgICAgICAgICAgICAgICA9IG1vdmVPcHRpb25zLnNwZWVkO1xuXG4gICAgICAgIHRoaXMuZmlyc3RNb3ZpbmdTdGVwT2NjdXJlZCAgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWF0ZTxFLCBXIGV4dGVuZHMgU2hhcmVkV2luZG93PiAoZWw6IEUsIHdpbjogVywgY3Vyc29yOiBDdXJzb3I8Vz4sIG1vdmVPcHRpb25zOiBNb3ZlT3B0aW9ucyk6IFByb21pc2U8TW92ZUF1dG9tYXRpb248RSwgVz4+IHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBvZmZzZXQgfSA9IGF3YWl0IE1vdmVBdXRvbWF0aW9uLmdldFRhcmdldChlbCwgd2luLCBuZXcgQXhpc1ZhbHVlcyhtb3ZlT3B0aW9ucy5vZmZzZXRYLCBtb3ZlT3B0aW9ucy5vZmZzZXRZKSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNb3ZlQXV0b21hdGlvbihlbGVtZW50LCBvZmZzZXQsIHdpbiwgY3Vyc29yLCBtb3ZlT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0VGFyZ2V0PEUsIFc+IChlbGVtZW50OiBFLCB3aW5kb3c6IFcsIG9mZnNldDogQXhpc1ZhbHVlc0RhdGE8bnVtYmVyPik6IFByb21pc2U8TW92ZUF1dG9tYXRpb25UYXJnZXQ8RT4+IHtcbiAgICAgICAgLy8gTk9URTogaWYgdGhlIHRhcmdldCBwb2ludCAoY29uc2lkZXJpbmcgb2Zmc2V0cykgaXMgb3V0IG9mXG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGNoYW5nZSB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50IGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZShhZGFwdGVyLnBvc2l0aW9uLmNvbnRhaW5zT2Zmc2V0KGVsZW1lbnQsIG9mZnNldC54LCBvZmZzZXQueSkpXG4gICAgICAgICAgICAudGhlbihjb250YWluc09mZnNldCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluc09mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXV0b21hdGlvblBvaW50KGVsZW1lbnQsIG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGFwdGVyLmRvbS5nZXREb2N1bWVudEVsZW1lbnQod2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChbcG9pbnQsIGRvY0VsXSkgPT4gKHsgZWxlbWVudDogZG9jRWwsIG9mZnNldDogcG9pbnQgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVsZW1lbnQsIG9mZnNldCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0Q3Vyc29yU3BlZWQgKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9tYXRpb25TZXR0aW5ncy5jdXJzb3JTcGVlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRUYXJnZXRDbGllbnRQb2ludCAoKTogUHJvbWlzZTxBeGlzVmFsdWVzPG51bWJlcj4+IHtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZShhZGFwdGVyLnN0eWxlLmdldEVsZW1lbnRTY3JvbGwodGhpcy5lbGVtZW50KSlcbiAgICAgICAgICAgIC50aGVuKHNjcm9sbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkYXB0ZXIuZG9tLmlzSHRtbEVsZW1lbnQodGhpcy5lbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEF4aXNWYWx1ZXMuY3JlYXRlKHRoaXMub2Zmc2V0KS5zdWIoQXhpc1ZhbHVlcy5jcmVhdGUoc2Nyb2xsKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlci5Qcm9taXNlQ3Rvci5yZXNvbHZlKGFkYXB0ZXIucG9zaXRpb24uZ2V0Q2xpZW50UG9zaXRpb24odGhpcy5lbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY2xpZW50UG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNEb2N1bWVudEJvZHkgPSBhZGFwdGVyLmRvbS5pc0JvZHlFbGVtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb2ludCAgICA9IEF4aXNWYWx1ZXMuY3JlYXRlKGNsaWVudFBvc2l0aW9uKS5hZGQodGhpcy5vZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRG9jdW1lbnRCb2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFBvaW50LnN1YihBeGlzVmFsdWVzLmNyZWF0ZShzY3JvbGwpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFBvaW50LnJvdW5kKE1hdGguZmxvb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldEV2ZW50U2VxdWVuY2VPcHRpb25zIChjdXJyUG9zaXRpb246IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGFkYXB0ZXIuZXZlbnQuQlVUVE9OU19QQVJBTUVURVIubm9CdXR0b247XG5cbiAgICAgICAgcmV0dXJuIGdldERldmljZVBvaW50KGN1cnJQb3NpdGlvbilcbiAgICAgICAgICAgIC50aGVuKGRldmljZVBvaW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IGN1cnJQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBjdXJyUG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuWDogZGV2aWNlUG9pbnQ/LngsXG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblk6IGRldmljZVBvaW50Py55LFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBidXR0b24sXG4gICAgICAgICAgICAgICAgICAgIGN0cmw6ICAgIHRoaXMubW9kaWZpZXJzLmN0cmwsXG4gICAgICAgICAgICAgICAgICAgIGFsdDogICAgIHRoaXMubW9kaWZpZXJzLmFsdCxcbiAgICAgICAgICAgICAgICAgICAgc2hpZnQ6ICAgdGhpcy5tb2RpZmllcnMuc2hpZnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGE6ICAgIHRoaXMubW9kaWZpZXJzLm1ldGEsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IGV2ZW50T3B0aW9ucywgZXZlbnRTZXF1ZW5jZU9wdGlvbnM6IHsgbW92ZUV2ZW50OiB0aGlzLm1vdmVFdmVudCB9IH07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9ydW5FdmVudFNlcXVlbmNlIChjdXJyZW50RWxlbWVudDogRWxlbWVudCwgeyBldmVudE9wdGlvbnMsIGV2ZW50U2VxdWVuY2VPcHRpb25zIH06IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IGV2ZW50U2VxdWVuY2UgPSBhd2FpdCBhZGFwdGVyLmNyZWF0ZUV2ZW50U2VxdWVuY2UoZmFsc2UsIHRoaXMuZmlyc3RNb3ZpbmdTdGVwT2NjdXJlZCwgZXZlbnRTZXF1ZW5jZU9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBldmVudFNlcXVlbmNlLnJ1bihcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50LFxuICAgICAgICAgICAgbGFzdEhvdmVyZWRFbGVtZW50SG9sZGVyLmdldCgpLFxuICAgICAgICAgICAgZXZlbnRPcHRpb25zLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9lbXVsYXRlRXZlbnRzIChjdXJyZW50RWxlbWVudDogRWxlbWVudCwgY3VyclBvc2l0aW9uOiBBeGlzVmFsdWVzPG51bWJlcj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEV2ZW50U2VxdWVuY2VPcHRpb25zKGN1cnJQb3NpdGlvbilcbiAgICAgICAgICAgIC50aGVuKG9wdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5FdmVudFNlcXVlbmNlKGN1cnJlbnRFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdE1vdmluZ1N0ZXBPY2N1cmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGxhc3RIb3ZlcmVkRWxlbWVudEhvbGRlci5zZXQoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbW92aW5nU3RlcCAoY3VyclBvc2l0aW9uOiBBeGlzVmFsdWVzPG51bWJlcj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmUoY3VyclBvc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gYWRhcHRlci5nZXRFbGVtZW50RXhjZXB0VUkodGhpcy5jdXJzb3IuZ2V0UG9zaXRpb24oKSkpXG4gICAgICAgICAgICAvLyBOT1RFOiBpbiB0b3VjaCBtb2RlLCBldmVudHMgYXJlIHNpbXVsYXRlZCBmb3IgdGhlIGVsZW1lbnQgZm9yIHdoaWNoIG1vdXNlZG93biB3YXMgc2ltdWxhdGVkIChHSC0zNzIpXG4gICAgICAgICAgICAudGhlbih0b3BFbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IHRoaXMuX2dldENvcnJlY3RlZFRvcEVsZW1lbnQodG9wRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBpdCBjYW4gYmUgbnVsbCBpbiBJRVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VtdWxhdGVFdmVudHMoY3VycmVudEVsZW1lbnQsIGN1cnJQb3NpdGlvbik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4obmV4dFRpY2spO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldENvcnJlY3RlZFRvcEVsZW1lbnQgKHRvcEVsZW1lbnQ6IEVsZW1lbnQpOiBFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRvcEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbW92ZSAoZW5kUG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzdGFydFBvaW50ID0gdGhpcy5jdXJzb3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgICA9IEF4aXNWYWx1ZXMuY3JlYXRlKGVuZFBvaW50KS5zdWIoc3RhcnRQb2ludCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSAgPSBhZGFwdGVyLm5hdGl2ZU1ldGhvZHMuZGF0ZU5vdygpO1xuICAgICAgICBjb25zdCBtb3ZpbmdUaW1lID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5hYnMoZGlzdGFuY2UueCksIE1hdGguYWJzKGRpc3RhbmNlLnkpKSAvIHRoaXMuY3Vyc29yU3BlZWQsIHRoaXMubWluTW92aW5nVGltZSk7XG4gICAgICAgIGxldCBjdXJyUG9zaXRpb24gPSBBeGlzVmFsdWVzLmNyZWF0ZShzdGFydFBvaW50KTtcbiAgICAgICAgbGV0IGlzRmlyc3RTdGVwICA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHdoaWxzdCgoKSA9PiAhY3VyclBvc2l0aW9uLmVxbChlbmRQb2ludCksICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkTW92ZUN1cnNvckltbWVkaWF0ZWx5KCkpXG4gICAgICAgICAgICAgICAgY3VyclBvc2l0aW9uID0gQXhpc1ZhbHVlcy5jcmVhdGUoZW5kUG9pbnQpO1xuXG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0U3RlcCkge1xuICAgICAgICAgICAgICAgIGlzRmlyc3RTdGVwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB0aGUgbW91c2Vtb3ZlIGV2ZW50IGNhbid0IGJlIHNpbXVsYXRlZCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgIC8vIHdhcyBsb2NhdGVkIGF0IHRoZSBzdGFydC4gVGhlcmVmb3JlLCB3ZSBhZGQgYSBtaW5pbWFsIGRpc3RhbmNlIDEgcHguXG4gICAgICAgICAgICAgICAgY3VyclBvc2l0aW9uLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIHg6IGRpc3RhbmNlLnggPiAwID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICB5OiBkaXN0YW5jZS55ID4gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oKGFkYXB0ZXIubmF0aXZlTWV0aG9kcy5kYXRlTm93KCkgLSBzdGFydFRpbWUpIC8gbW92aW5nVGltZSwgMSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyUG9zaXRpb24gPSBBeGlzVmFsdWVzLmNyZWF0ZShkaXN0YW5jZSkubXVsKHByb2dyZXNzKS5hZGQoc3RhcnRQb2ludCkucm91bmQoTWF0aC5mbG9vcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb3ZpbmdTdGVwKGN1cnJQb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL1xuICAgIHByaXZhdGUgX25lZWRNb3ZlQ3Vyc29ySW1tZWRpYXRlbHkgKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b3VjaE1vZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2Nyb2xsICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgaWYgKHRoaXMuc2tpcFNjcm9sbGluZylcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbE9wdGlvbnMgPSBuZXcgU2Nyb2xsT3B0aW9ucyh7IG9mZnNldFg6IHRoaXMub2Zmc2V0LngsIG9mZnNldFk6IHRoaXMub2Zmc2V0LnkgfSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBhZGFwdGVyLnNjcm9sbCh0aGlzLmVsZW1lbnQsIHNjcm9sbE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21vdmVUb0N1cnJlbnRGcmFtZSAoZW5kUG9pbnQ6IEF4aXNWYWx1ZXM8bnVtYmVyPik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IuaXNBY3RpdmUodGhpcy53aW5kb3cpKVxuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZSgpO1xuXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ICAgICAgICA9IHRoaXMuY3Vyc29yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVdpbmRvdyAgICA9IHRoaXMuY3Vyc29yLmdldEFjdGl2ZVdpbmRvdyh0aGlzLndpbmRvdyk7XG4gICAgICAgIGxldCBpZnJhbWU6IGFueSAgICAgICA9IG51bGw7XG4gICAgICAgIGxldCBpZnJhbWVVbmRlckN1cnNvcjogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IG1zZzogYW55ID0ge1xuICAgICAgICAgICAgY21kOiAgICAgICBNT1ZFX1JFUVVFU1RfQ01ELFxuICAgICAgICAgICAgc3RhcnRYOiAgICB4LFxuICAgICAgICAgICAgc3RhcnRZOiAgICB5LFxuICAgICAgICAgICAgZW5kWDogICAgICBlbmRQb2ludC54LFxuICAgICAgICAgICAgZW5kWTogICAgICBlbmRQb2ludC55LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB0aGlzLm1vZGlmaWVycyxcbiAgICAgICAgICAgIHNwZWVkOiAgICAgdGhpcy5zcGVlZCxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYWRhcHRlci5Qcm9taXNlQ3Rvci5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlV2luZG93LnBhcmVudCA9PT0gdGhpcy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXIuUHJvbWlzZUN0b3IucmVzb2x2ZShhZGFwdGVyLmRvbS5maW5kSWZyYW1lQnlXaW5kb3coYWN0aXZlV2luZG93KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUgPSBmcmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLlByb21pc2VDdG9yLnJlc29sdmUoYWRhcHRlci5wb3NpdGlvbi5nZXRJZnJhbWVDbGllbnRDb29yZGluYXRlcyhmcmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlY3QgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmxlZnQgICA9IHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZy50b3AgICAgPSByZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5yaWdodCAgPSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmJvdHRvbSA9IHJlY3QuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLmdldEVsZW1lbnRFeGNlcHRVSSh0aGlzLmN1cnNvci5nZXRQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbih0b3BFbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZnJhbWVVbmRlckN1cnNvciA9IHRvcEVsZW1lbnQgPT09IGlmcmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVXaW5kb3cucGFyZW50ID09PSB0aGlzLndpbmRvdylcbiAgICAgICAgICAgICAgICAgICAgbXNnLmlmcmFtZVVuZGVyQ3Vyc29yID0gaWZyYW1lVW5kZXJDdXJzb3I7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlci5zZW5kUmVxdWVzdFRvRnJhbWUobXNnLCBNT1ZFX1JFU1BPTlNFX0NNRCwgYWN0aXZlV2luZG93KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zZXRBY3RpdmVXaW5kb3codGhpcy53aW5kb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlmcmFtZVVuZGVyQ3Vyc29yIHx8IGFkYXB0ZXIuZG9tLmlzSWZyYW1lV2luZG93KHRoaXMud2luZG93KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yLm1vdmUobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHJ1biAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGwoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRhcmdldENsaWVudFBvaW50KCksXG4gICAgICAgICAgICAgICAgYWRhcHRlci5zdHlsZS5nZXRXaW5kb3dEaW1lbnNpb25zKHRoaXMud2luZG93KSxcbiAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgLnRoZW4oKFtlbmRQb2ludCwgYm91bmRhcnldKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZGFyeS5jb250YWlucyhlbmRQb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW92ZVRvQ3VycmVudEZyYW1lKGVuZFBvaW50KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLl9tb3ZlKGVuZFBvaW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=